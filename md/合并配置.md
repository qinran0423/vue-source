# 合并配置



```javascript
Vue.mixin({
    created() {
    	console.log('parent created');
    }
 })
const app = new Vue({
    el: "#app",
    data: {
        foo: 'foo',
    },
    created() {
        console.log('child created');
    },
    mounted() {
        console.log('child mounted');
    },
});
    
```

##  Vue mixin 合并

首先执行的是全局API的注册

src\core\global-api\index.js -> src\core\global-api\mixin.js 中的 initMixin(Vue)

```javascript
export function initMixin (Vue: GlobalAPI) {
  Vue.mixin = function (mixin: Object) {
    this.options = mergeOptions(this.options, mixin)
    return this
  }
}

```

this代表Vue   执行mergeOptions(src\core\util\options.js)  传入 Vue的options 和 mixin中的对象

此时parent: 代表Vue的options   child：mixin中的对象

```javascript
parent: {
    components: {},
    directives: {},
    filters: {}
}
```

为什么parent中有这些东西？再次回到全局API注册方法initGlobalAPI中

```javascript
Vue.options = Object.create(null)

// ['component' , 'filter', 'directives'] 三个选项的初始化
ASSET_TYPES.forEach(type => {
    Vue.options[type + 's'] = Object.create(null)
})
Vue.options._base = Vue
```

### 遍历parent

遍历parent的属性 并执行mergeField（key） key-> componets, filters, directives _base

#### 遍历components

```javascript
    mergeField(componetns)

    function mergeField (key) {
        const strat = strats[key] || defaultStrat
        options[key] = strat(parent[key], child[key], vm, key)
    }

```
就是执行 

```javascript
ASSET_TYPES.forEach(function (type) {
  strats[type + 's'] = mergeAssets
})
```

就是执行 mergeAssets
```javascript
    function mergeAssets (
    parentVal: ?Object,
    childVal: ?Object,
    vm?: Component,
    key: string
    ): Object {
        const res = Object.create(parentVal || null)
        if (childVal) {
            return extend(res, childVal)
        } else {
            return res
        }
    }
```

parentVal： parent[componets] -> {KeepAlive, Transition, TransitionGroup}

res: {}
所以上面的 mergeField 中 options[components] = {}   他的__proto__ -> {KeepAlive, Transition, TransitionGroup}

#### 遍历directives

也是执行 mergeAssets

parentVal： parent[directives] -> {model, show} v-model, v-show

res: {}

所以上面的 mergeField 中 options[directives] = {}   他的__proto__ -> {model, show}

#### 遍历filters

也是执行 mergeAssets

parentVal:  {}

res: {}

所以上面的 mergeField 中 options[filters] = {}   他的__proto__ -> {}

#### 遍历_base

此时没有找到strats[_base]所以走了defaultstrat

```javascript
const defaultStrat = function (parentVal: any, childVal: any): any {
  return childVal === undefined
    ? parentVal
    : childVal
}
```

因为上面的Vue.options._base = Vue

parentVal: Vue

childVal: undefined

所以上面的 mergeField 中 options[_base] = Vue

### 遍历child

此时的child 就是mixin中传入的对象 此时只有created

```javascript
for (key in child) {
    if (!hasOwn(parent, key)) {
      mergeField(key)
    }
  }
```

遍历child中的key 之后就判断key 在parent中是否出现，如果没有出现则mergeField

执行mergeField(created)

#### 生命周期合并

```javascript
LIFECYCLE_HOOKS.forEach(hook => {
  strats[hook] = mergeHook
})

```

所以strats[created] 执行的是mergeHook 

此时parentVal是undefined,所以返回 [created]

```javascript
function mergeHook (
  parentVal: ?Array<Function>,
  childVal: ?Function | ?Array<Function>
): ?Array<Function> {
  const res = childVal
    ? parentVal
      ? parentVal.concat(childVal)
      : Array.isArray(childVal)
        ? childVal
        : [childVal]
    : parentVal
  return res
    ? dedupeHooks(res)
    : res
}
```

所以最后返回的options是

```javascript
{
    components: {},
    directives: {},
    filters: {},
    _base: Vue,
    created:[created]
}
```



## 合并组建配置



